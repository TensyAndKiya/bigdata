一、MapReduce编程模型
思想：分成两个阶段，map阶段和reduce阶段；
map阶段将大的任务，切分成小任务，分散到不同的服务器中，并行的执行（减少每个服务器的计算负载，同时减少整体的计算时间）；
reduce阶段，将map阶段的结果做一下汇总

map阶段的输入、输出都是以kv对的形式；输出结果写入map任务所在服务器的本地磁盘
reduce阶段的输入来自map阶段的输出；reduce的输出结果也是kv对，默认存储到HDFS中

二、MapReduce编程示例
1、写三个主要的代码
自定义的map类
	在map方法中，编写业务代码
自定义的reduce类
	在reduce方法中，编写业务代码
程序入口main
	编写程序入口
	
2、可以本地运行
3、集群运行

三、combiner
combiner的原理，map端本地聚合
其本质是一个reducer类

四、shuffle
shuffle主要指的map端的输出，然后如何传输到reduce task的过程

map端：
	输出是kv对，先写入环形缓冲区（100M），当达到80%后，缓冲区中的数据开始溢出写磁盘文件；
	溢出过程中，有以下几个操作：
	1、根据reduce个数对kv对做分区；
	2、每个分区中，根据kv对的key做排序；
	3、若有map端本地聚合combine，则对每个分区中，同组数据（默认指key相同的kv对）的values做聚合
	在溢出写的过程中，可以继续向环形缓冲区写入数据；但是若写入速度大于溢出写的速度，当100m占满后，暂停向环形缓冲区中写入的过程；只执行溢出写的过程；直到全部溢出写到磁盘，才恢复向缓冲区写入

	随着不断的溢出写磁盘文件，本地磁盘会生成多个溢出文件，在map task完成之前，溢出文件会被合并成一个已分区、已排序的输出文件

reduce端：
	reduce task会在每个map task运行完成后，获得map task输出中，属于自己的分区数据（许多kv对）；
	数据先在reduce的jvm内存中，如果数据占空间变大，则合并后溢出写磁盘文件；若指定了combine，在合并时，运行它，减少写入磁盘的数据量。
	随着溢出文件的增多，会合并文件
	所有map task复制完成后，进入“合并阶段”；维持原顺序排序

	每组合并后的数据，调用一次reduce方法



